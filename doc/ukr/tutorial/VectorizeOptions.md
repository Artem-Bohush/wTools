# Опції векторизації

Як використовувати опції рутини <code>vectorize</code> при створенні векторизованої рутини.

[Огляд рутини `vectorize`](Vectorize.md) розкриває її призначення та базові можливості. В цьому туторіалі ви ознайомитесь
із розширеними налаштуваннями векторизації рутин.

### Передача налаштувань для векторизації рутини

Векторизувати рутину за допомогою `vectorize` можна двома способами:

- через передачу аргументів, перший з яких - скалярна рутина, а другий - аргумент `select`, котрий впливає на поведінку
векторизованої рутини. Наприклад, якщо в `select` передати числове значення, то це визначить кількість аргументів для
векторизованої рутини

```js
var someRoutineVector = _.vectorize( someRoutine, 2 );
```

Векторизована рутина `someRoutineVector`, створена з рутини `someRoutine`, приймає лише два аргументи. Якщо не вказати
аргумент `select`, то рутина `vectorize` встановить значення за замовчуванням - `1`.

- через передачу мапи опцій. Для векторизації рутини створюється мапа опцій, котра повинна містити поле `routine` - рутина
для векторизації, та додатково може містити поля: `select`, `fieldFilter`, `bypassingFilteredOut`, `bypassingEmpty`,
`vectorizingArray`, `vectorizingMapVals`, `vectorizingMapKeys`. Створена мапа опцій передається в рутину `vectorize`

```js
var option =
{
  routine : someRoutine,
}
var someRoutineVector = _.vectorize( option );
```

Приведений приклад показує як векторизувати рутину `someRoutine` з допомогою мапи опцій. Результуюча рутина
`someRoutineVector` матиме налаштування за замовчуваннями.

### Опція `select`

При створенні векторизованої рутини опція `select` має першочергове значення після опції `routine`. Опція приймає числові
значення, що більші або рівні `1`. Якщо передано числове значення, то це значення визначає кількість аргументів, що буде
приймати векторизована рутина. Якщо потрібно, щоб векторизована рутина приймала необмежену кількість аргументів в опції
вказується значення `Infinity`. За замовчуванням опція має значення `1`.

Також опція `select` може мати рядкове значення, або бути масивом. Використання рядкового значення або масиву впливає на
обробку векторизованою рутиною ключів в переданих мапах.

Згідно опису, приведеного вище, є чотири напрями обробки вхідних даних в залежності від значення опції `select`:

- коли опція `select` має скінчене числове значення більше від `1`;
- коли опція `select` має значення `Infinity`;
- коли опція `select` має рядкове значення;
- опція `select` має значення в вигляді масиву.

### Векторизація рутини коли опція `select >= 1`

Напрям включає множину варіантів векторизації. Застосування окремого визначається набором опцій:

- якщо `vectorizingArray : 0`, `vectorizingMapVals : 0`, `vectorizingMapKeys : 0` рутина залишається без змін, тобто,
скалярною;
- якщо в `fieldFilter` передано рутину-фільтр, то векторизована рутина виконує операції лише для елементів, що задовільняють
умовам фільтра;
- якщо `vectorizingMapKeys : 1` i `vectorizingMapVals : 1` - векторизована рутина виконує операцію для кожного ключа і кожного
значення в переданій мапі. Якщо передано масив значень і опція `vectorizingArray : 1`, то операція виконується над кожним
елементом масиву. При такій комбінації опцій можливо передати лише один аргумент векторизованій рутині;
- якщо `vectorizingMapKeys : 1` i `vectorizingMapVals : 0` - векторизована рутина може проводити операцію з ключами мап та
елементами масивів, при цьому значення пар `ключ-значення` мапи присвоюється результату виконання дії;
- якщо `vectorizingArray : 0` i `vectorizingMapVals : 1` - векторизована рутина виконує операцію над значеннями мапи, при
цьому ключі залишаються без змін;
- якщо `vectorizingArray : 1`, `select >=2`, а інші опції зкинуті - векторизована рутина виконує операції лише з елементами
переданих масивів;
- у всіх інших випадках (`vectorizingArray : 1`, `select == 1`, а інші опції зкинуті) - векторизована рутина виконує операцію
з окремими елементами переданого в першому аргументі масиву.

### Дослідження варіантів векторизації

<details>
  <summary><u>Структура файлів</u></summary>

```
vectorize
   ├── Vectorize.js
   └── package.json
```

</details>

Для дослідження варіантів векторизації створіть новий файл `Vectorize.js` в директорії `Vectorize`, для встановлення
залежностей створіть файл `package.json`.

<details>
    <summary><u>Код файла <code>package.json</code></u></summary>

```json    
{
  "dependencies": {
    "wTools": ""
  }
}
```

</details>

Для використання рутини `vectorize` потрібно підключити модуль `Tools`. Скопіюйте приведений вище код в файл `package.json`
та встановіть залежності з допомогою команди `npm install`. Після встановлення залежностей модуль буде готовий до роботи.

#### Приклад векторизації при `vectorizingMapKeys : 1` і `vectorizingMapVals : 1`

Опція `vectorizingMapKeys` дозволяє рутині розглядати ключі в мапі як елементи вектора, а `vectorizingMapVals` дозволяє
рутині розглядати значення в мапі як елементи вектора. За замовчуванням опції `vectorizingMapKeys` і `vectorizingMapVals`
зкинуті.

<details>
    <summary><u>Код файла <code>Vectorize.js</code></u></summary>

```js   
let _ = require( 'wTools' );

// scalar routine
function sum( a )
{
  return a + 5;
}

// vectorized routine
var o =
{
  routine : sum,
  vectorizingMapKeys : 1,
  vectorizingMapVals : 1,
  select : 1,
}
let sumV = _.vectorize( o );

// log examples
console.log( sumV( [ 0, 1, 2, 'a' ] ) );
console.log( sumV( { a : 'a', b : 4, c : 5 } ) );
```

</details>

Помістіть приведений вище код в файл `Vectorize.js`.

Рутину `sum`, котра повертає суму першого аргумента і числа `5`, векторизовано з опціями `vectorizingMapKeys : 1` i
`vectorizingMapVals : 1`. Опція `vectorizingArray` встановлена за замовчуванням - `1`.

Такий набір опцій означає, що при виконанні операцій з масивами, рутина додасть число `5` до елементів масиву. При роботі з
мапами, рутина `sumV` додаватиме число `5`, як до ключа, так і до значення.

<details>
    <summary><u>Вивід команди <code>node Vectorize.js</code></u></summary>

```
$ node Vectorize.js
[ 5, 6, 7, 'a5' ]
[Object: null prototype] { a5: 'a5', b5: 9, c5: 10 }  
```

</details>

В директорії файла `Vectorize.js` виконайте команду `node Vectorize.js`. Порівняйте вивід з приведеним.

В першому рядку виводу отримано масив в якому до кожного елемента додано `5`. В другому рядку показано вивід при передачі
мапи - рутина `sumV` відповідним чином змінила пари `ключ-значення`.

#### Приклад векторизації при `vectorizingArray : 1`, `vectorizingMapKeys : 0` і `vectorizingMapVals : 0`

<details>
    <summary><u>Код файла <code>Vectorize.js</code></u></summary>

```js   
let _ = require( 'wTools' );

// scalar routine
function arr()
{
  return _.longSlice( arguments );
}

// vectorized routine
var o =
{
  routine : arr,
  vectorizingArray : 1,
  select : 2,
}
let arrV = _.vectorize( o );

// log examples
console.log( arrV( [ 0, 1, 2, 'a' ], [ 1, 2, 3, 4 ] ) );
console.log( arrV( { a : 5 }, [ 1, 2, 3 ] ) );
console.log( arrV( { a : 5 }, 1 ) );
```

</details>

Замініть вміст файла `Vectorize.js` на приведений.

Рутина `longSlice`, що поміщена в рутину `arr`, належить модулю `Tools`. Рутина `longSlice` копіює ділянку масиву переданого
першим аргументом, скопійована ділянка може бути обмежена значеннями другого і третього аргументів. Оскільки обмежень не
встановлено, рутина `longSlice` поверне масив створений із аргументів.

Оскільки опція `select` має значення `2`, то векторизована рутина завжди створюватиме масив із двох значень. Якщо передати
в рутину більше або менше аргументів ніж `2`, то рутина викине помилку про невідповідність кількості аргументів.

Окрім цього, оскільки, опції `vectorizingMapKeys` і `vectorizingMapVals` зкинуті, рутина `arrV` вважатиме вектором лише
передані масиви, а інші елементи будуть розглядатись як скалярні.

Запустіть виконання файла командою `node Vectorize.js`

<details>
    <summary><u>Вивід команди <code>node Vectorize.js</code></u></summary>

```
$ node Vectorize.js
[ [ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 'a', 4 ] ]
[ [ { a: 5 }, 1 ], [ { a: 5 }, 2 ], [ { a: 5 }, 3 ] ]
[ { a: 5 }, 1 ]
```

</details>

Перший рядок виводу консолі показує, що рутина створює масив аргументів для кожної пари елементів в переданих векторах.
Відповідно, в першому рядку виведено масив в який вкладено чотири інших. Другий рядок показує, що через зкинуті опції
`vectorizingMap*` мапа розглядається як скалярний елемент. Мапа `{ a : 5 }` векторно об'єднана з кожним елементом масиву
`[ 1, 2, 3 ]`. В третьому рядку виводу показано, що якщо аргументи не містять векторів, то вони відразу передаються в рутину
`longSlice`.

### Векторизація рутини коли опція `select === Infinity`

Якщо опція `select === Infinity` то векторизація проходить за сценаріями, котрі описані в пункті де опція
[`select >= 1`](#векторизація-рутини-коли-опція-select--1). При цьому знімається обмеження на кількість аргументів,
що передаються в векторизовану рутину. Рутина, що векторизована при значенні `select : Infinity` може приймати довільну
кількість аргументів, включаючи відсутність аргументів.

### Векторизація рутини коли опція `select` має рядкове значення

При використанні рядкового значення векторизована рутина може прийняти лише один аргумент. Рутина розглядає значення `select`
як ключ для пошуку в мапі. Якщо за таким ключем в переданій мапі знайдено вектор, то рутина розкладає мапу на множину мап
згідно кількості елементів вектора.

<details>
    <summary><u>Код файла <code>Vectorize.js</code></u></summary>

```js   
let _ = require( 'wTools' );

// scalar routine
function arr()
{
  return _.longSlice( arguments );
}

// vectorized routine
var o =
{
  routine : arr,
  vectorizingArray : 1,
  select : 'a',
}
let selectByKey = _.vectorize( o );

// log examples
console.log( selectByKey( [ 0, 1, 2, 'a' ] ) );
console.log( selectByKey( { a : 2, b : [ 3, 4 ] } ) );
console.log( selectByKey( { a : [ 5, 4, 3 ], b : [ 1, 2], c : 0 } ) );
```

</details>

Внесіть в файл `Vectorize.js` приведений код.

Рутина `selectByKey` розкладатиме передані мапи, якщо за ключем `a` поміщено вектор.

Запустіть виконання файла командою `node Vectorize.js`

<details>
    <summary><u>Вивід команди <code>node Vectorize.js</code></u></summary>

```
$ node Vectorize.js
[ [ 0, 1, 2, 'a' ] ]
[ { a: 2, b : [ 3, 4 ] } ]
[ [ [Object: null prototype] { a: 5, b: [Array], c: 0 } ],
  [ [Object: null prototype] { a: 4, b: [Array], c: 0 } ],
  [ [Object: null prototype] { a: 3, b: [Array], c: 0 } ] ]
```

</details>

Перший рядок виводу показує, що рутина розглядає масив як скаляр. В другому рядку мапа має ключ `a` зі скалярним значенням
тому розкладення не відбулось. Вивід в якому мапу розкладено на складові за указаним ключем приведений в рядках 3-5. Кожен
елемент вектору, що поміщений за ключем `a` було розглянуто як скалярне значення.

### Векторизація рутини коли опція `select` - масив

Подібно до випадку з рядковим значенням, векторизована рутина розглядає елементи масиву як ключі для мапи опцій за якими її
потрібно розкласти. Таким чином можна отримати таку кількість мап, скільки є елементів в векторах за вказаними ключами.

<details>
    <summary><u>Код файла <code>Vectorize.js</code></u></summary>

```js   
let _ = require( 'wTools' );

// scalar routine
function arr()
{
  return _.longSlice( arguments );
}

// vectorized routine
var o =
{
  routine : arr,
  vectorizingArray : 1,
  select : [ 'a', 'b' ],
}
let selectByKeys = _.vectorize( o );

// log examples
let result = selectByKeys( { a : [ 5, 4, 3 ], b : [ 'a', 2 ] } );
console.log( result );
for( let i = 0; i < result.length; i++ )
console.log( result[ i ] );
```

</details>

Внесіть в файл `Vectorize.js` приведений код.

Рутина `selectByKey` розкладатиме передані мапи, якщо за ключами `a` і `b` поміщено вектор.

Запустіть виконання файла командою `node Vectorize.js`

<details>
    <summary><u>Вивід команди <code>node Vectorize.js</code></u></summary>

```
$ node Vectorize.js
[ [ [ [Object] ], [ [Object] ], [ [Object] ] ],
  [ [ [Object] ], [ [Object] ] ] ]
[ [ [Object: null prototype] { a: 5, b: [Array] } ],
  [ [Object: null prototype] { a: 4, b: [Array] } ],
  [ [Object: null prototype] { a: 3, b: [Array] } ] ]
[ [ [Object: null prototype] { a: [Array], b: 'a' } ],
  [ [Object: null prototype] { a: [Array], b: 2 } ] ]
```

</details>

При виводі результату видно, що всього було створено п'ять мап (`[ [Object] ]`), котрі згруповано по ключу - три з них
вкладено в один з підмасивів, а два - в інший. Детальна інформація по підгрупам показана нижче в виводі. В підгрупі з трьох
елементів мапу розкладено за ключем `a`, в підгрупі з двома елементами - за ключем `b`.

### Опції-фільтри `bypassingFilteredOut` i `bypassingEmpty`

Опція `bypassingFilteredOut` має значення лише якщо встановлено рутину-фільтр в опції `fieldFilter`. Опція визначає поведінку
рутини з елементами, що не задовільняють умовам фільтра. При `bypassingFilteredOut : 1` - елементи, що не були відібрані
фільтром додаються до результуючого масиву без змін, а при `bypassingFilteredOut : 0` - пропускаються.

Опція `bypassingEmpty` призначена для встановлення поведінки рутини при відсутності вводу. Опція має значення якщо
`select : Infinity`, оскільки ця опція дозволяє вводити довільне число аргументів, в тому числі залишити рутину без вводу.
Опція експериментальна, може працювати некоректно.

### Підсумок

- При передачі в рутину `vectorize` двох аргументів, перший з них - рутина для векторизації, а другий - опція `select`. При
цьому, інші налаштування встановлюються за замовчуванням.
- При векторизації рутини з допомогою мапи опцій в рутину `vectorize` передається лише мапа опцій. З допомогою мапи опцій
можливо змінити налаштування за замовчуванням.
- Опція `select` визначає варіанти векторизації рутини. Опція `select` може приймати числове значення що быльше або рівне `1`,
`Infinity`, рядкове значення або бути масивом.
- Числові значення опції `select` встановлюють кількість аргументів для векторизованої рутини.
- Значення `Infinity` в опції `select` дозволяє передавати довільну кількість аргументів в векторизовану рутину.
- При передачі рядкового значення в опції `select`, рутина шукає ідентичний ключ в мапі. Якщо за ключем поміщений вектор, то
рутина розкладає таку мапу за кількістю елементів вектора.
- Опція `vectorizingArray` дозволяє рутині розглядати масив як вектор.
- Опція `vectorizingMapKeys` дозволяє рутині розглядати ключі мапи як елементи вектора.
- Опція `vectorizingMapVals` дозволяє рутині розглядати значення в парах `ключ-значення` як елементи вектора.
- Опція `fieldFilter` встановлює фільтр за яким здійснюється відбір елементів в векторах.

[Повернутись до змісту](../README.md#Туторіали)
